## 系统架构设计
我们将系统拆分为 **用户服务、权限服务、日志服务** 四个核心微服务，并依赖一套标准化的基础架构层（Nacos, RocketMQ等）。

#### 系统架构图
![](https://cdn.nlark.com/yuque/0/2025/png/56328710/1750227015714-f01c1349-8ee5-42de-ad2c-8f01f5276b34.png)

**架构解读:**

+ **客户端 (Client)**: Web/App前端，通过公网访问系统。
+ **用户服务 (User Service)**: 
    - 用户注册
    - 用户登录
    - 用户登出
    - 获取当前登录用户信息
    - 分页查询用户列表
    - 查询指定用户信息
    - 修改用户信息
    - 修改密码
    - 重置密码
    - 升级用户角色
    - 降级用户角色
+ **权限服务 (Permission Service)**: 负责角色管理和用户-角色关系的维护，为其他服务提供权限查询的RPC接口。
    - （用户注册时）绑定默认角色
    - 角色数据初始化
    - 查询用户角色
    - 升级用户角色
    - 降级用户角色
+ **日志服务 (Logging Service)**: 作为一个独立的MQ消费者，异步地将操作日志持久化到MySQL，与主业务完全解耦。
    - 异步记录操作日志



---



## 详细功能列表
#### 一、 用户服务
| 功能点 (Feature) | 详细描述 | 权限要求 |
| :--- | :--- | :--- |
| **1. 用户注册** | 提供接口允许新用户通过用户名、密码、邮箱进行注册。 | `公开 (Public)` |
| **2. 用户登录** | 用户通过用户名/邮箱和密码进行登录，验证成功后返回JWT Token。 | `公开 (Public)` |
| **3. 用户登出** | 提供接口使用户的当前Token失效。 | `登录用户` |
| **4. 获取当前登录用户信息** | 用户通过Token获取自己的完整信息（不含密码）。 | `登录用户` |
| **5. 分页查询用户列表** | 管理员/超管可以分页、排序、筛选（如按用户名模糊搜索）查询用户列表。 | `管理员`, `超级管理员` |
| **6. 查询指定用户信息** | 根据`userId`查询某个用户的详细信息。 | `本人`, `管理员`, `超级管理员` |
| **7. 修改用户信息** | 用户可以修改自己的个人信息（如邮箱、手机号）。管理员/超管可修改他人信息。 | `本人`, `管理员`, `超级管理员` |
| **8. 修改密码** | 登录用户提供旧密码和新密码，验证通过后修改自己的密码。 | `本人` |
| **9. 重置密码** | 管理员/超管可以强制重置指定用户的密码（例如，重置为随机密码或初始密码）。 | `管理员`, `超级管理员` |


#### 二、 权限与角色
| 功能点 (Feature) | 详细描述 | 权限要求 |
| :--- | :--- | :--- |
| **1. 角色数据初始化** | 系统启动时，自动初始化一个超级管理员。 | `系统内部` |
| **2. 绑定默认角色** | 在用户注册时，自动为新用户绑定为`普通用户(user)`角色。 | `系统内部 (RPC调用)` |
| **3. 查询用户角色** | 提供内部接口，根据`userId`查询其对应的角色。 | `系统内部 (RPC调用)` |
| **4. 升级用户角色** | 超管可以将一个`普通用户`的角色提升为`管理员`。 | `超级管理员` |
| **5. 降级用户角色** | 超管可以将一个`管理员`的角色降级为`普通用户`。 | `超级管理员` |


#### 三、 日志
| 功能点 (Feature) | 详细描述 | 权限要求 |
| :--- | :--- | :--- |
| **1. 异步记录操作日志** | 异步消费MQ中的日志消息，并将其持久化到`operation_logs`数据库表中。 | `系统内部 (MQ消费者)` |


---

## 系统技术骨架
### 一、 核心框架与服务治理
#### 1. Spring Boot
+ **核心功能**：一个用于快速构建独立、生产级Spring应用程序的框架。它简化了配置，内嵌了Web服务器（如Tomcat），让开发者能专注于业务逻辑。
+ **在本系统中的作用**：作为所有三个微服务（`user-service`, `permission-service`, `logging-service`）的基础开发框架。每个服务都是一个独立的Spring Boot应用，可以独立开发、部署和伸缩。

#### 2. Spring Cloud & Spring Cloud Alibaba
+ **核心功能**：一套用于构建分布式系统的工具集。Spring Cloud Alibaba是其子项目，提供了与阿里巴巴开源组件（如Nacos, Seata）无缝集成的能力。
+ **在本系统中的作用**：是整个微服务架构的“粘合剂”。它将Nacos、OpenFeign、Seata等组件整合到Spring Boot应用中，提供了服务治理、通信、分布式事务等一系列解决方案。

#### 3. Nacos
+ **核心功能**：一个集服务注册与发现、配置管理于一体的基础设施。
+ **在本系统中的作用**：
    - **服务注册与发现**：所有微服务在启动时，都会将自己的服务名和IP地址注册到Nacos。当`user-service`需要调用`permission-service`时，它会向Nacos询问“`permission-service`在哪里？”，Nacos会返回一个可用的服务实例地址。这实现了服务间的动态发现和负载均衡。
    - **配置中心**：可以将数据库连接信息、RocketMQ地址、JWT密钥等配置信息集中存储在Nacos中。所有微服务从Nacos动态拉取配置，实现了配置的集中管理和热更新，无需重启服务即可修改配置。

### 二、 数据层技术
#### 4. MySQL
+ **核心功能**：业界主流的关系型数据库管理系统（RDBMS）。
+ **在本系统中的作用**：作为所有业务数据的最终持久化存储。
    - **用户服务**：使用两个库（`user_db_0`, `user_db_1`）来存储分片后的用户数据。
    - **权限服务**：使用一个独立的库（`permission_db`）来存储角色和用户角色关系数据。
    - **日志服务**：使用一个独立的库（`logging_db`）来存储操作日志。

#### 5. ShardingSphere-JDBC
+ **核心功能**：一个开源的分布式数据库中间件，提供数据分片（分库分表）、读写分离、分布式主键等功能。
+ **在本系统中的作用**：
    - **解决用户表单表性能瓶颈**：在`user-service`中使用，对`users`表进行水平分片。当用户数据量巨大时，通过将数据分散到多个库和表中，显著提升数据库的写入和查询性能。
    - **对业务透明**：应用程序（`user-service`）编写的仍然是针对逻辑表`users`的SQL，ShardingSphere-JDBC驱动会自动解析SQL，根据`user_id`这个分片键，将请求路由到正确的物理数据库和物理表中。
    - **分布式ID生成**：内置了Snowflake算法，用于在用户注册时生成全局唯一的`user_id`，解决了分片后主键唯一性问题。

### 三、 服务间通信
#### 6. OpenFeign
+ **核心功能**：一个声明式的、模板化的HTTP客户端。开发者只需创建一个接口并用注解进行配置，即可完成对远程HTTP服务的调用。
+ **在本系统中的作用**：作为`user-service`和`permission-service`之间的**RPC（远程过程调用）通信框架**。`user-service`通过一个`PermissionFeignClient`接口来调用`permission-service`提供的功能（如绑定角色、查询角色），就像调用本地方法一样简洁，屏蔽了底层的HTTP请求细节。

#### 7. RocketMQ
+ **核心功能**：一款低延迟、高吞吐、高可用的分布式消息队列（MQ）。
+ **在本系统中的作用**：
    - **异步处理**：将“记录操作日志”这个非核心、但可能耗时的操作从主业务流程（如用户注册）中剥离出来。`user-service`在完成注册后，只需快速地向RocketMQ发送一条日志消息即可立即返回，无需等待日志写入数据库。
    - **系统解耦**：`user-service`不直接与`logging-service`通信，只与MQ打交道。`logging-service`也只关心消费MQ中的消息。两者完全解耦，`logging-service`的启停、升级、故障完全不影响`user-service`的正常运行。
    - **流量削峰**：在高并发场景下，如果大量操作同时产生日志，MQ可以作为缓冲区，让`logging-service`按照自己的处理能力平稳地消费数据，避免瞬间的数据库写入压力冲垮日志系统。

### 四、 分布式事务与安全
#### 8. Seata
+ **核心功能**：阿里巴巴开源的分布式事务解决方案，旨在提供高性能且易于使用的分布式事务服务。
+ **在本系统中的作用**：**保障跨服务数据一致性**。在“用户注册”流程中，涉及两个操作：1）`user-service`在`users`表插入数据；2）`permission-service`在`user_roles`表插入数据。这两个操作必须**原子执行**。Seata通过AT模式（自动补偿事务），确保这两个跨服务的数据库操作要么同时成功，要么同时失败（回滚），从而避免了“用户创建了但没有角色”这种数据不一致状态的发生。

#### 9. JSON Web Token (JWT)
+ **核心功能**：一个开放标准（RFC 7519），它定义了一种紧凑的、自包含的方式，用于在各方之间安全地传输信息（作为JSON对象）。
+ **在本系统中的作用**：作为**用户认证和授权的凭证**。
    - **认证**：用户登录成功后，`user-service`会生成一个包含`userId`等信息的JWT并返回给客户端。
    - **无状态授权**：客户端在后续的每次请求中，都需要在请求头携带这个JWT。服务端通过验证JWT的签名来确认用户的身份，并从中解析出`userId`和角色信息，进行权限校验。由于用户信息包含在Token中，服务端无需依赖Session，实现了无状态服务，更易于水平扩展。

### 技术组件功能汇总表
| 技术组件 | 核心功能 | 在本系统中的具体作用 |
| --- | --- | --- |
| **Spring Boot** | 快速应用开发框架 | 构建所有三个独立微服务（User, Permission, Logging）的基础 |
| **Spring Cloud Alibaba** | 微服务解决方案套件 | 整合并管理Nacos, Feign, Seata等组件，是微服务架构的粘合剂 |
| **Nacos** | 服务注册发现 & 配置中心 | 服务地址管理、动态配置管理 |
| **MySQL** | 关系型数据库 | 持久化存储用户、角色、日志等所有业务数据 |
| **ShardingSphere-JDBC** | 分布式数据库中间件 | 对用户表进行分库分表，解决数据量瓶颈，生成分布式ID |
| **OpenFeign** | 声明式HTTP客户端 | 实现用户服务到权限服务的RPC（远程过程调用） |
| **RocketMQ** | 分布式消息队列 | 异步处理操作日志，实现服务解耦和流量削峰 |
| **Seata** | 分布式事务解决方案 | 保证用户注册与角色绑定的跨服务操作的原子性（数据一致性） |
| **JWT** | JSON Web Token | 生成用户登录凭证，实现无状态的认证与授权 |




---



## <font style="color:rgb(26, 28, 30);">功能点-技术组件依赖</font>
### **一、 用户服务 (user-service)**
| <font style="color:rgb(26, 28, 30);">功能点 (Feature)</font> | <font style="color:rgb(26, 28, 30);">涉及的技术组件</font> | <font style="color:rgb(26, 28, 30);">核心交互/逻辑</font> |
| --- | --- | --- |
| **1. 用户注册** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">OpenFeign</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Seata</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Nacos</font>` | <font style="color:rgb(26, 28, 30);">这是一个</font>**高度协作**<font style="color:rgb(26, 28, 30);">的功能：</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供</font>`<font style="color:rgb(26, 28, 30);">/user/register</font>`<font style="color:rgb(26, 28, 30);"> RESTful接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**ShardingSphere-JDBC**<font style="color:rgb(26, 28, 30);">：生成分布式唯一</font>`<font style="color:rgb(26, 28, 30);">user_id</font>`<font style="color:rgb(26, 28, 30);">（雪花算法），并根据分片规则将用户数据写入正确的</font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">物理库/表。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**Seata**<font style="color:rgb(26, 28, 30);">：启动全局事务，确保第2步（写用户库）和第4步（写权限库）的原子性。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**OpenFeign + Nacos**<font style="color:rgb(26, 28, 30);">：通过服务发现，RPC调用</font>`<font style="color:rgb(26, 28, 30);">permission-service</font>`<font style="color:rgb(26, 28, 30);">的</font>`<font style="color:rgb(26, 28, 30);">bindDefaultRole</font>`<font style="color:rgb(26, 28, 30);">接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">5. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：在事务成功提交后，发送一条"REGISTER"日志消息到消息队列，实现业务与日志的解耦。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">6. </font>**MySQL**<font style="color:rgb(26, 28, 30);">：作为</font>`<font style="color:rgb(26, 28, 30);">users</font>`<font style="color:rgb(26, 28, 30);">表的最终存储。</font> |
| **2. 用户登录** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供</font>`<font style="color:rgb(26, 28, 30);">/user/login</font>`<font style="color:rgb(26, 28, 30);">接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：根据用户名查询</font>`<font style="color:rgb(26, 28, 30);">users</font>`<font style="color:rgb(26, 28, 30);">表，验证密码是否正确。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**JWT**<font style="color:rgb(26, 28, 30);">：密码验证成功后，使用</font>`<font style="color:rgb(26, 28, 30);">jjwt</font>`<font style="color:rgb(26, 28, 30);">等库生成一个包含</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">和过期时间的Token。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：发送"LOGIN"日志消息。</font> |
| **3. 用户登出** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供</font>`<font style="color:rgb(26, 28, 30);">/user/logout</font>`<font style="color:rgb(26, 28, 30);">接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**JWT**<font style="color:rgb(26, 28, 30);">：服务端验证Token有效性。</font>**注意**<font style="color:rgb(26, 28, 30);">：要真正使JWT失效，通常需要引入Redis等缓存作为黑名单，此处简化为仅记录登出行为。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：发送"LOGOUT"日志消息。</font> |
| **4. 获取当前登录用户信息** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供</font>`<font style="color:rgb(26, 28, 30);">/user/me</font>`<font style="color:rgb(26, 28, 30);">之类的接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**JWT**<font style="color:rgb(26, 28, 30);">：通过拦截器或</font>`<font style="color:rgb(26, 28, 30);">Spring Security</font>`<font style="color:rgb(26, 28, 30);">解析请求头中的Token，获取</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：使用解析出的</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">查询</font>`<font style="color:rgb(26, 28, 30);">users</font>`<font style="color:rgb(26, 28, 30);">表，返回用户信息。</font> |
| **5. 分页查询用户列表** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">OpenFeign</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Nacos</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供</font>`<font style="color:rgb(26, 28, 30);">/users</font>`<font style="color:rgb(26, 28, 30);">接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**JWT**<font style="color:rgb(26, 28, 30);">：解析Token获取当前操作者的</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**OpenFeign + Nacos**<font style="color:rgb(26, 28, 30);">：RPC调用</font>`<font style="color:rgb(26, 28, 30);">permission-service</font>`<font style="color:rgb(26, 28, 30);">的</font>`<font style="color:rgb(26, 28, 30);">getUserRoleCode</font>`<font style="color:rgb(26, 28, 30);">接口，查询当前操作者的角色以进行</font>**权限判断**<font style="color:rgb(26, 28, 30);">。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：根据权限结果，执行相应的分页查询。ShardingSphere会处理跨库/跨表的分页、排序和聚合。</font> |
| **6. 查询指定用户信息** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">OpenFeign</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Nacos</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>` | <font style="color:rgb(26, 28, 30);">与功能5类似，核心在于</font>**权限校验**<font style="color:rgb(26, 28, 30);">：</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">1. </font>**JWT**<font style="color:rgb(26, 28, 30);">：获取当前登录用户ID。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**OpenFeign + Nacos**<font style="color:rgb(26, 28, 30);">：获取当前用户角色。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**业务逻辑判断**<font style="color:rgb(26, 28, 30);">：判断当前用户是否有权查询目标</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">的信息（本人/管理员/超管）。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：权限通过后，查询目标</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">的数据。</font> |
| **7. 修改用户信息** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">OpenFeign</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Nacos</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>` | <font style="color:rgb(26, 28, 30);">流程与功能6类似，但增加了写操作和日志记录：</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">1-3. 与功能6相同的权限校验流程。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：权限通过后，执行</font>`<font style="color:rgb(26, 28, 30);">UPDATE</font>`<font style="color:rgb(26, 28, 30);">操作。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">5. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：发送"UPDATE_USER_INFO"日志消息，消息体中可包含修改前后的详情。</font> |
| **8. 修改密码** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**JWT**<font style="color:rgb(26, 28, 30);">：解析Token获取</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：先根据</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">查询出旧密码进行比对，验证通过后再执行</font>`<font style="color:rgb(26, 28, 30);">UPDATE</font>`<font style="color:rgb(26, 28, 30);">操作更新为新密码。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：发送"CHANGE_PASSWORD"日志消息。</font> |
| **9. 重置密码** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">JWT</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">OpenFeign</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Nacos</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">ShardingSphere-JDBC</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供接口。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**JWT + OpenFeign + Nacos**<font style="color:rgb(26, 28, 30);">：与功能5一样，先进行权限校验，确保操作者是管理员或超管。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**ShardingSphere-JDBC + MySQL**<font style="color:rgb(26, 28, 30);">：权限通过后，直接</font>`<font style="color:rgb(26, 28, 30);">UPDATE</font>`<font style="color:rgb(26, 28, 30);">目标用户的密码。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">4. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：发送"RESET_PASSWORD"日志消息。</font> |


---

### **二、 权限与角色 (permission-service)**
| <font style="color:rgb(26, 28, 30);">功能点 (Feature)</font> | <font style="color:rgb(26, 28, 30);">涉及的技术组件</font> | <font style="color:rgb(26, 28, 30);">核心交互/逻辑</font> |
| --- | --- | --- |
| **1. 角色数据初始化** | `<font style="color:rgb(26, 28, 30);">Spring Boot</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>` | <font style="color:rgb(26, 28, 30);">通常通过</font>`<font style="color:rgb(26, 28, 30);">CommandLineRunner</font>`<font style="color:rgb(26, 28, 30);">或</font>`<font style="color:rgb(26, 28, 30);">@PostConstruct</font>`<font style="color:rgb(26, 28, 30);">实现。在</font>`<font style="color:rgb(26, 28, 30);">permission-service</font>`<font style="color:rgb(26, 28, 30);">启动时，检查</font>`<font style="color:rgb(26, 28, 30);">roles</font>`<font style="color:rgb(26, 28, 30);">表，如果</font>`<font style="color:rgb(26, 28, 30);">super_admin</font>`<font style="color:rgb(26, 28, 30);">等核心角色不存在，则执行</font>`<font style="color:rgb(26, 28, 30);">INSERT</font>`<font style="color:rgb(26, 28, 30);">语句进行初始化。</font>`<font style="color:rgb(26, 28, 30);">user_roles</font>`<font style="color:rgb(26, 28, 30);">表也可以在此处初始化超级管理员的绑定关系。</font> |
| **2. 绑定默认角色** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">Seata</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供一个</font>**内部RESTful接口**<font style="color:rgb(26, 28, 30);">（如</font>`<font style="color:rgb(26, 28, 30);">/internal/permission/bindDefault</font>`<font style="color:rgb(26, 28, 30);">），供</font>`<font style="color:rgb(26, 28, 30);">user-service</font>`<font style="color:rgb(26, 28, 30);">通过Feign调用。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**MySQL**<font style="color:rgb(26, 28, 30);">：在</font>`<font style="color:rgb(26, 28, 30);">user_roles</font>`<font style="color:rgb(26, 28, 30);">表中插入一条记录，将</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">与"普通用户"的</font>`<font style="color:rgb(26, 28, 30);">role_id</font>`<font style="color:rgb(26, 28, 30);">关联。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**Seata**<font style="color:rgb(26, 28, 30);">：作为分布式事务的</font>**参与方**<font style="color:rgb(26, 28, 30);">，其数据源被Seata RM代理，确保此操作能被全局事务协调和回滚。</font> |
| **3. 查询用户角色** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>` | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供一个</font>**内部RESTful接口**<font style="color:rgb(26, 28, 30);">（如</font>`<font style="color:rgb(26, 28, 30);">/internal/permission/roleCode</font>`<font style="color:rgb(26, 28, 30);">）。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**MySQL**<font style="color:rgb(26, 28, 30);">：根据传入的</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">，联查</font>`<font style="color:rgb(26, 28, 30);">user_roles</font>`<font style="color:rgb(26, 28, 30);">和</font>`<font style="color:rgb(26, 28, 30);">roles</font>`<font style="color:rgb(26, 28, 30);">表，返回对应的</font>`<font style="color:rgb(26, 28, 30);">role_code</font>`<font style="color:rgb(26, 28, 30);">（如 "admin"）。</font> |
| **4. 升级用户角色** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>`<font style="color:rgb(26, 28, 30);"> (可选)</font> | <font style="color:rgb(26, 28, 30);">1. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：提供一个</font>**对外RESTful接口**<font style="color:rgb(26, 28, 30);">（如</font>`<font style="color:rgb(26, 28, 30);">/roles/upgrade</font>`<font style="color:rgb(26, 28, 30);">），需要权限校验。   </font><font style="color:rgb(26, 28, 30);">2. </font>**MySQL**<font style="color:rgb(26, 28, 30);">：在</font>`<font style="color:rgb(26, 28, 30);">user_roles</font>`<font style="color:rgb(26, 28, 30);">表中，将指定</font>`<font style="color:rgb(26, 28, 30);">userId</font>`<font style="color:rgb(26, 28, 30);">的</font>`<font style="color:rgb(26, 28, 30);">role_id</font>`<font style="color:rgb(26, 28, 30);">更新为"管理员"的</font>`<font style="color:rgb(26, 28, 30);">role_id</font>`<font style="color:rgb(26, 28, 30);">。   </font><font style="color:rgb(26, 28, 30);">3. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);"> : 发送"UPGRADE_ROLE"日志消息，此日志由</font>`<font style="color:rgb(26, 28, 30);">permission-service</font>`<font style="color:rgb(26, 28, 30);">自己发出，记录权限变更的关键操作。</font> |
| **5. 降级用户角色** | `<font style="color:rgb(26, 28, 30);">Spring Boot (Web/MVC)</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>`<font style="color:rgb(26, 28, 30);"> (可选)</font> | <font style="color:rgb(26, 28, 30);">与功能4逻辑完全相同，只是将</font>`<font style="color:rgb(26, 28, 30);">role_id</font>`<font style="color:rgb(26, 28, 30);">更新为"普通用户"的</font>`<font style="color:rgb(26, 28, 30);">role_id</font>`<font style="color:rgb(26, 28, 30);">，并发送"DOWNGRADE_ROLE"日志消息。</font> |


---

### **三、 日志 (logging-service)**
| <font style="color:rgb(26, 28, 30);">功能点 (Feature)</font> | <font style="color:rgb(26, 28, 30);">涉及的技术组件</font> | <font style="color:rgb(26, 28, 30);">核心交互/逻辑</font> |
| --- | --- | --- |
| **1. 异步记录操作日志** | `<font style="color:rgb(26, 28, 30);">Spring Boot</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">RocketMQ</font>`<font style="color:rgb(26, 28, 30);">, </font>`<font style="color:rgb(26, 28, 30);">MySQL</font>` | <font style="color:rgb(26, 28, 30);">这是一个</font>**纯后台服务**<font style="color:rgb(26, 28, 30);">，没有对外接口：</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">1. </font>**RocketMQ**<font style="color:rgb(26, 28, 30);">：作为消费者，通过</font>`<font style="color:rgb(26, 28, 30);">@RocketMQMessageListener</font>`<font style="color:rgb(26, 28, 30);">注解监听指定的日志Topic。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">2. </font>**Spring Boot**<font style="color:rgb(26, 28, 30);">：管理消费者的生命周期和依赖注入。</font><font style="color:rgb(26, 28, 30);">   </font><font style="color:rgb(26, 28, 30);">3. </font>**MySQL**<font style="color:rgb(26, 28, 30);">：当收到消息后，解析消息内容（</font>`<font style="color:rgb(26, 28, 30);">OperationLogEvent</font>`<font style="color:rgb(26, 28, 30);">对象），将其中的信息组装成</font>`<font style="color:rgb(26, 28, 30);">OperationLog</font>`<font style="color:rgb(26, 28, 30);">实体，并插入到</font>`<font style="color:rgb(26, 28, 30);">operation_logs</font>`<font style="color:rgb(26, 28, 30);">数据库表中。</font> |




---



## API 接口设计
当然，接口设计是项目实现的蓝图。一个好的RESTful接口设计应该遵循**资源导向**、**职责清晰**、**命名规范**和**状态码准确**的原则。

下面我将为这个用户权限管理系统中所有需要对外或对内暴露的功能点设计RESTful接口。

---

### **接口设计约定**
+ **Base URL**:  `user-service` 的基础路径是 `/user`，`permission-service` 的基础路径是 `/permission`。
+ **统一响应格式**: 所有接口返回统一的JSON结构，便于客户端处理。

```json
{
  "code": 200, // 业务状态码, 200表示成功
  "message": "Success", // 提示信息
  "data": { ... } // 业务数据
}
```

+ **认证**: 需要登录的接口，客户端需在请求头中携带 `Authorization: Bearer <jwt_token>`。
+ **内部接口**: 供服务间调用的接口，路径以 `/internal` 开头，以示区分。这些接口不应直接暴露给外部用户。

---

### **一、 用户服务 (User Service)**
**服务基础路径**: `/user`

| 功能点 | HTTP方法 | URL路径 | 请求体 (Request Body) / 查询参数 (Query Params) | 权限要求 | 成功响应 (200 OK) |
| --- | --- | --- | --- | --- | --- |
| **1. 用户注册** | `POST` | `/register` | **Body**: `{ "username": "string", "password": "string", "email": "string" }` | 公开 (Public) | `{ "code": 200, "message": "注册成功", "data": { "userId": 12345, "username": "newUser" } }` |
| **2. 用户登录** | `POST` | `/login` | **Body**: `{ "username": "string", "password": "string" }` | 公开 (Public) | `{ "code": 200, "message": "登录成功", "data": { "token": "ey...", "expiresIn": 7200 } }` |
| **3. 用户登出** | `POST` | `/logout` | _无_ | 登录用户 | `{ "code": 200, "message": "登出成功", "data": null }` |
| **4. 获取当前用户信息** | `GET` | `/me` | _无_ | 登录用户 | `{ "code": 200, "message": "Success", "data": { "userId": 123, "username": "test", "email": "test@example.com", "phone": "138..." } }` |
| **5. 分页查询用户列表** | `GET` | `/users` | **Params**: `page=1`, `size=10`, `sort=gmt_create,desc`, `username=test` (可选) | 管理员, 超管 | `{ "code": 200, "message": "Success", "data": { "content": [ ...user objects... ], "page": 1, "size": 10, "totalPages": 5, "totalElements": 48 } }` |
| **6. 查询指定用户信息** | `GET` | `/user/{userId}` | _无_ (userId从路径获取) | 本人, 管理员, 超管 | `{ "code": 200, "message": "Success", "data": { "userId": 456, "username": "anotherUser", ... } }` |
| **7. 修改用户信息** | `PUT` | `/user/{userId}` | **Body**: `{ "email": "new.email@example.com", "phone": "139..." }` | 本人, 管理员, 超管 | `{ "code": 200, "message": "用户信息修改成功", "data": { ...updated user object... } }` |
| **8. 修改密码** | `PUT` | `/password` | **Body**: `{ "oldPassword": "string", "newPassword": "string" }` | 本人 | `{ "code": 200, "message": "密码修改成功", "data": null }` |
| **9. 重置密码** | `POST` | `/user/{userId}/reset-password` | _无_ | 管理员, 超管 | `{ "code": 200, "message": "密码已重置为: <new_random_password>", "data": { "newPassword": "<new_random_password>" } }` |


---

### **二、 权限服务 (Permission Service)**
**服务基础路径**: `/permission`

| 功能点 | HTTP方法 | URL路径 | 请求体 (Request Body) / 查询参数 (Query Params) | 权限要求 | 成功响应 (200 OK) |
| --- | --- | --- | --- | --- | --- |
| **2. 绑定默认角色 (内部)** | `POST` | `/internal/roles/bind-default` | **Body**: `{ "userId": 12345 }`    _(Feign通常转为_`@RequestParam`_)_ | 系统内部 | `{ "code": 200, "message": "默认角色绑定成功", "data": null }` (或者直接返回 HTTP 204 No Content) |
| **3. 查询用户角色 (内部)** | `GET` | `/internal/user/{userId}/role` | _无_ (userId从路径获取) | 系统内部 | `{ "code": 200, "message": "Success", "data": { "roleCode": "admin" } }` |
| **4. 升级用户角色** | `PUT` | `/user/{userId}/upgrade-to-admin` | _无_ | 超级管理员 | `{ "code": 200, "message": "用户角色已升级为管理员", "data": { "userId": 456, "newRole": "admin" } }` |
| **5. 降级用户角色** | `PUT` | `/user/{userId}/downgrade-to-user` | _无_ | 超级管理员 | `{ "code": 200, "message": "用户角色已降级为普通用户", "data": { "userId": 789, "newRole": "user" } }` |


#### **接口设计思考**:
+ **资源化**: `GET /users`, `GET /user/{userId}`, `PUT /user/{userId}` 都体现了对 `user` 资源的增删改查。
+ **动词与名词**: HTTP方法（GET, POST, PUT, DELETE）是动词，URL路径尽量使用名词（资源）。对于无法清晰映射到CRUD的操作，如“重置密码”，可以使用子资源或动作形式，如 `/user/{userId}/reset-password`，这比 `/resetPassword` 更符合REST风格。
+ **内部与外部隔离**: 使用 `/internal` 路径前缀明确标记了服务间调用的接口。
+ **参数传递**:
    - **路径参数 (**`{userId}`**)**: 用于唯一标识一个资源。
    - **查询参数 (**`?key=value`**)**: 用于对资源集合进行过滤、排序、分页。
    - **请求体 (**`Body`**)**: 用于传递复杂的资源对象（如创建或修改用户）。

---

### **三、 日志服务 (Logging Service)**
这个服务是纯粹的后台消费者，**不提供任何RESTful接口**。它只通过`RocketMQ`的SDK与消息队列进行交互，消费`user-service`和`permission-service`产生的日志消息。

这种设计是**异步和解耦**的最佳实践，日志系统对核心业务系统是“透明”的，核心业务系统也不需要关心日志系统是否存在或是否正常工作。



---



## 数据库设计
### **设计原则**
1. **服务隔离 (Database per Service)**: 每个微服务拥有自己独立的数据库，避免跨库直连，保证服务的独立性和数据所有权。
    - `user-service` -> `user_db_0`, `user_db_1`
    - `permission-service` -> `permission_db`
    - `logging-service` -> `logging_db`
2. **分片设计**: `user-service` 的用户数据是核心且可能快速增长的数据，因此对其进行水平分片（分库分表）。
3. **命名规范**: 表名使用复数形式（如 `users`），字段名使用下划线命名法（如 `user_id`），清晰易懂。
4. **索引优化**: 为频繁查询的字段（如外键、唯一键、查询条件字段）创建索引，提高查询性能。

---

### **一、 用户服务数据库 (分库分表)**
这个服务的数据将被水平分片到两个数据库 (`user_db_0`, `user_db_1`) 中，每个数据库中又包含两个表 (`users_0`, `users_1`)。ShardingSphere 将会管理这些物理表，对应用层来说，它只操作逻辑表 `users`。

**逻辑表名**: `users`  
**分片键**: `user_id`

#### **数据库和表结构 (DDL)**
你需要在两个MySQL实例或同一个实例中创建以下两个数据库和表，它们的结构是完全相同的。

**数据库 1: **`user_db_0`

```sql
-- 创建数据库 user_db_0
CREATE DATABASE IF NOT EXISTS user_db_0 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE user_db_0;

-- 分表 1
CREATE TABLE users_0 (
                         `user_id` BIGINT NOT NULL COMMENT '用户ID (雪花算法生成)',
                         `username` VARCHAR(50) NOT NULL COMMENT '用户名',
                         `password` VARCHAR(255) NOT NULL COMMENT '加密后的密码',
                         `email` VARCHAR(100) NULL COMMENT '邮箱',
                         `phone` VARCHAR(20) NULL COMMENT '手机号',
                         `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                         `gmt_modified` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
                         PRIMARY KEY (`user_id`),
                         UNIQUE KEY `uk_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表分片0';

-- 分表 2
CREATE TABLE users_1 (
                         `user_id` BIGINT NOT NULL COMMENT '用户ID (雪花算法生成)',
                         `username` VARCHAR(50) NOT NULL COMMENT '用户名',
                         `password` VARCHAR(255) NOT NULL COMMENT '加密后的密码',
                         `email` VARCHAR(100) NULL COMMENT '邮箱',
                         `phone` VARCHAR(20) NULL COMMENT '手机号',
                         `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                         `gmt_modified` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
                         PRIMARY KEY (`user_id`),
                         UNIQUE KEY `uk_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表分片1';
```

**数据库 2: **`user_db_1`

```sql
-- 创建数据库 user_db_1
CREATE DATABASE IF NOT EXISTS user_db_1 CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE user_db_1;

-- 分表 1
CREATE TABLE users_0 (
                         `user_id` BIGINT NOT NULL COMMENT '用户ID (雪花算法生成)',
                         `username` VARCHAR(50) NOT NULL COMMENT '用户名',
                         `password` VARCHAR(255) NOT NULL COMMENT '加密后的密码',
                         `email` VARCHAR(100) NULL COMMENT '邮箱',
                         `phone` VARCHAR(20) NULL COMMENT '手机号',
                         `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                         `gmt_modified` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
                         PRIMARY KEY (`user_id`),
                         UNIQUE KEY `uk_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表分片0';

-- 分表 2
CREATE TABLE users_1 (
                         `user_id` BIGINT NOT NULL COMMENT '用户ID (雪花算法生成)',
                         `username` VARCHAR(50) NOT NULL COMMENT '用户名',
                         `password` VARCHAR(255) NOT NULL COMMENT '加密后的密码',
                         `email` VARCHAR(100) NULL COMMENT '邮箱',
                         `phone` VARCHAR(20) NULL COMMENT '手机号',
                         `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
                         `gmt_modified` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
                         PRIMARY KEY (`user_id`),
                         UNIQUE KEY `uk_username` (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表分片1';
```

#### **关键字段说明**:
+ `user_id`: **主键 & 分片键**。使用 ShardingSphere 的 Snowflake 算法生成，保证全局唯一。
+ `username`: 用户名必须唯一，因此创建了唯一索引 `uk_username`。
+ `gmt_create` / `gmt_modified`: 记录创建和修改时间，是表设计的良好实践。

---

### **二、 权限服务数据库 (单库)**
权限相关的数据量相对较小且稳定，不需要分片。

**数据库名**: `permission_db`

#### **表结构 (DDL)**
```sql
CREATE DATABASE IF NOT EXISTS permission_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE permission_db;

-- 1. 角色表 (roles)
CREATE TABLE roles (
  `role_id` INT NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `role_code` VARCHAR(20) NOT NULL COMMENT '角色代码 (程序中使用)',
  `role_name` VARCHAR(50) NOT NULL COMMENT '角色名称 (用于显示)',
  `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`role_id`),
  UNIQUE KEY `uk_role_code` (`role_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色信息表';

-- 2. 用户-角色关系表 (user_roles)
CREATE TABLE user_roles (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `user_id` BIGINT NOT NULL COMMENT '用户ID (关联users表的user_id)',
  `role_id` INT NOT NULL COMMENT '角色ID (关联roles表的role_id)',
  `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_user_id` (`user_id`),
  KEY `idx_role_id` (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户角色关系表';

-- 初始化数据
INSERT INTO `roles` (`role_id`, `role_code`, `role_name`) VALUES
(1, 'super_admin', '超级管理员'),
(2, 'admin', '管理员'),
(3, 'user', '普通用户');

-- 初始化一个超级管理员，假设其 user_id 为 1
INSERT INTO `user_roles` (`user_id`, `role_id`) VALUES (1, 1);
```

#### **关键字段说明**:
+ `roles` 表: 定义了系统中存在的所有角色。`role_code` 是程序逻辑中用于判断权限的依据。
+ `user_roles` 表: 核心关系表。
    - `uk_user_id`: **唯一索引**，确保一个用户只有一个角色，符合题目要求。
    - `idx_role_id`: 普通索引，如果需要查询某个角色下的所有用户，这个索引会很有用。

---

### **三、 日志服务数据库 (单库)**
日志数据会持续增长，但在本系统简化版中，我们先使用单库单表。在生产环境中，可能会考虑使用时序数据库（如 InfluxDB）或对日志表进行按月分表。

**数据库名**: `logging_db`

#### **表结构 (DDL)**
```sql
CREATE DATABASE IF NOT EXISTS logging_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
USE logging_db;

CREATE TABLE operation_logs (
  `log_id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '日志ID',
  `user_id` BIGINT NULL COMMENT '操作者用户ID',
  `trace_id` VARCHAR(50) NULL COMMENT '分布式链路追踪ID',
  `action` VARCHAR(50) NOT NULL COMMENT '操作类型 (如 REGISTER, UPDATE_USER)',
  `ip` VARCHAR(45) NULL COMMENT '操作者IP地址',
  `detail` TEXT NULL COMMENT '操作详情 (JSON格式, 记录修改内容等)',
  `gmt_create` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '操作时间',
  PRIMARY KEY (`log_id`),
  KEY `idx_user_id_action` (`user_id`, `action`),
  KEY `idx_gmt_create` (`gmt_create`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='操作日志表';
```

#### **关键字段说明**:
+ `log_id`: 自增主键。
+ `trace_id`: **(推荐增加)** 用于关联一次完整请求在多个微服务间的调用链，便于问题排查。可以使用 SkyWalking 或 Seata 的 `XID` 作为 `trace_id`。
+ `detail`: 使用 `TEXT` 类型存储 JSON 字符串，可以灵活记录各种操作的详细信息，如 `{"field":"email", "oldValue":"a@a.com", "newValue":"b@b.com"}`。
+ `idx_user_id_action` / `idx_gmt_create`: 建立索引，方便按用户、按操作类型或按时间范围查询日志。

这份数据库设计方案涵盖了题目要求的所有功能，并考虑了微服务架构下的数据隔离和扩展性，可以作为你项目开发的坚实基础。



---



## 领域模型和实体分析
这份分析将把设计文档中的业务概念，转化为软件开发中具体的类和对象，主要包括 **实体 (Entity)**、**数据传输对象 (DTO)** 和 **视图对象 (VO)**，并阐明它们之间的关系和在各个微服务中的归属。

---

### **一、 领域模型分析概述**
领域模型是业务领域的核心概念及其关系的软件化表达。在微服务架构中，每个服务都维护着自己边界内的领域模型。

+ **实体 (Entity)**: 直接映射到数据库表的持久化对象。它包含了业务数据和部分业务逻辑，并且具有唯一的标识符（ID）。实体是服务的核心资产，其生命周期由数据库管理。
+ **数据传输对象 (DTO - Data Transfer Object)**: 用于在不同层（如 Controller 和 Service）或不同服务之间（如 RPC 调用）传递数据的对象。它的主要作用是聚合数据，减少调用次数，并作为 API 的输入契约，与内部实体解耦。
+ **视图对象 (VO - View Object)**: 用于将数据呈现给客户端（前端）的对象。它专为展示而生，可以对实体数据进行裁剪、格式化或聚合，确保返回给前端的数据不多不少，且格式友好。

这种 **Entity -> DTO / VO** 的分层模型是构建健壮、安全、可维护的现代应用的基石。

---

### **二、 核心实体 (Entity) 分析**
#### **1. 用户 (User)**
+ **描述**: 系统的核心参与者，拥有身份凭证和个人信息。它是 **用户服务** 的**聚合根**（Aggregate Root），所有与单个用户相关的操作都围绕它展开。
+ **归属服务**: `user-service`
+ **对应数据表**: `users` (逻辑表)
+ **Java 实体定义 (**`User.java`**)**:

```java
import javax.persistence.*;
import java.sql.Timestamp;

@Entity
@Table(name = "users") // ShardingSphere会处理到物理表的路由
public class User {

    @Id
    // ShardingSphere会自动注入雪花算法生成的ID，此处无需@GeneratedValue
    @Column(name = "user_id")
    private Long userId;

    @Column(name = "username", nullable = false, unique = true, length = 50)
    private String username;

    @Column(name = "password", nullable = false, length = 255)
    private String password; // 存储的是加密后的哈希值

    @Column(name = "email", length = 100)
    private String email;

    @Column(name = "phone", length = 20)
    private String phone;

    @Column(name = "gmt_create", updatable = false)
    private Timestamp gmtCreate;

    @Column(name = "gmt_modified")
    private Timestamp gmtModified;

    // Getters and Setters
}
```

#### **2. 角色 (Role)**
+ **描述**: 定义了一组权限的集合。它是系统中权限的基本单位，相对静态。
+ **归属服务**: `permission-service`
+ **对应数据表**: `roles`
+ **Java 实体定义 (**`Role.java`**)**:

```java
import javax.persistence.*;

@Entity
@Table(name = "roles")
public class Role {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "role_id")
    private Integer roleId;

    @Column(name = "role_code", nullable = false, unique = true, length = 20)
    private String roleCode; // e.g., "super_admin", "admin", "user"

    @Column(name = "role_name", nullable = false, length = 50)
    private String roleName; // e.g., "超级管理员", "管理员", "普通用户"

    // Getters and Setters
}
```

#### **3. 用户角色关系 (UserRole)**
+ **描述**: 连接用户和角色的关系实体，明确了某个用户具体拥有哪个角色。
+ **归属服务**: `permission-service`
+ **对应数据表**: `user_roles`
+ **Java 实体定义 (**`UserRole.java`**)**:

```java
import javax.persistence.*;

@Entity
@Table(name = "user_roles", uniqueConstraints = {
    @UniqueConstraint(columnNames = "user_id") // 保证一个用户只有一个角色
})
public class UserRole {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    @Column(name = "user_id", nullable = false)
    private Long userId; // 引用 User 实体的 ID

    @Column(name = "role_id", nullable = false)
    private Integer roleId; // 引用 Role 实体的 ID

    // Getters and Setters
}
```

#### **4. 操作日志 (OperationLog)**
+ **描述**: 记录系统中的关键操作，用于审计和问题排查。
+ **归属服务**: `logging-service`
+ **对应数据表**: `operation_logs`
+ **Java 实体定义 (**`OperationLog.java`**)**:

```java
import javax.persistence.*;
import java.sql.Timestamp;

@Entity
@Table(name = "operation_logs")
public class OperationLog {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "log_id")
    private Long logId;

    @Column(name = "user_id")
    private Long userId;

    @Column(name = "trace_id", length = 50)
    private String traceId; // 分布式链路追踪ID

    @Column(name = "action", nullable = false, length = 50)
    private String action; // e.g., "REGISTER", "UPDATE_USER"

    @Column(name = "ip", length = 45)
    private String ip;

    @Lob // 表示大文本字段
    @Column(name = "detail")
    private String detail; // JSON格式的详细信息

    @Column(name = "gmt_create", updatable = false)
    private Timestamp gmtCreate;

    // Getters and Setters
}
```

---

### **三、 数据传输对象 (DTO) 分析**
DTO 是 API 的“输入契约”，它们精确地定义了客户端需要提供哪些数据来完成一个操作。

#### **User Service DTOs**
+ `UserRegisterDTO.java`: 用于用户注册。

```java
import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

public class UserRegisterDTO {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 3, max = 50, message = "用户名长度必须在3到50之间")
    private String username;

    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6到20之间")
    private String password;

    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    private String email;
    // Getters and Setters
}
```

+ `UserLoginDTO.java`: 用于用户登录。

```java
public class UserLoginDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
    @NotBlank(message = "密码不能为空")
    private String password;
    // Getters and Setters
}
```

+ `UserUpdateDTO.java`: 用于更新用户信息。字段都是可选的。

```java
@Email
private String email;
@Size(min = 11, max = 11)
private String phone;
// Getters and Setters
```

+ `ChangePasswordDTO.java`: 用于用户自己修改密码。

```java
public class ChangePasswordDTO {
    @NotBlank private String oldPassword;
    @NotBlank @Size(min = 6, max = 20) private String newPassword;
    // Getters and Setters
}
```

#### **Log DTO**
+ `OperationLogDTO.java` (或 `LogMessage.java`): 用于在服务间通过 RocketMQ 传递日志信息。

```java
import java.io.Serializable;

public class OperationLogDTO implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long userId;
    private String traceId;
    private String action;
    private String ip;
    private String detail; // JSON String
    // Constructor, Getters and Setters
}
```

---

### **四、 视图对象 (VO) 分析**
VO 是 API 的“输出契约”，它们定义了成功操作后返回给客户端的数据结构。

+ `UserVO.java`: 用于展示用户信息的标准视图，**绝不包含密码**。

```java
public class UserVO {
    private Long userId;
    private String username;
    private String email;
    private String phone;
    private String roleCode; // 可能需要聚合权限服务的数据
    private Timestamp gmtCreate;
    // Getters and Setters
}
```

+ `LoginVO.java`: 用于登录成功后返回 Token。

```java
public class LoginVO {
    private String token;
    private Long expiresIn; // Token有效期（秒）
    // Getters and Setters
}
```

+ `PageVO.java`: 一个通用的分页结果视图对象。

```java
import java.util.List;

public class PageVO<T> {
    private List<T> content; // 当前页数据
    private int page;        // 当前页码
    private int size;        // 每页大小
    private long totalElements; // 总记录数
    private int totalPages;     // 总页数
    // Getters and Setters
}
```

例如，查询用户列表的接口将返回 `PageVO<UserVO>` 类型的数据。

---

### **五、 实体关系图**
下图展示了核心实体之间的关系（跨越了不同的数据库）。

![](https://cdn.nlark.com/yuque/__mermaid_v3/9c6e9ab1a33a9705df1be43d03cd37f1.svg)

### **总结**
1. **明确了数据所有权**：每个实体都清晰地归属于一个微服务。
2. **定义了数据结构**：通过 Java 类的形式，精确定义了每个实体的属性和约束。
3. **设计了API契约**：通过 DTO 和 VO，将内部数据模型与外部 API 调用解耦，提高了系统的安全性和灵活性。
4. **可视化了关系**：通过 ER 图，直观地展示了跨服务的数据关联。



---



## 详细用例规格说明
---

### **详细用例规格说明书**
本文档概述了用户权限管理系统每个功能需求的详细流程。

### **第一部分: 用户服务用例**
`user-service` 负责所有以用户为中心的操作，包括注册、认证和个人资料管理。

---

#### **1. 用例: 用户注册**
+ **Actor(s)**: 未认证的用户 (公开)
+ **目标**: 在系统中创建一个新的用户账户，该过程还会为用户分配一个默认角色并记录创建事件。
+ **前置条件**: 无。

##### **基本流程 (Happy Path)**
1. **API 请求**: 客户端向 `/user/register` 发送一个 `POST` 请求。请求体是一个 JSON 对象: `{ "username": "string", "password": "string", "email": "string" }`。
2. **事务启动 (**`user-service`**)**: 控制器接收到请求。服务方法被 `@GlobalTransactional` 注解标记，这会通知 **Seata** 开始一个新的全局事务。
3. **ID 生成 (**`user-service`**)**: **ShardingSphere-JDBC** 的内置雪花算法为新用户生成一个全局唯一的 `user_id`。这个 `user_id` 将作为分片键。
4. **用户数据持久化 (**`user-service`**)**:
    - 服务准备一条针对逻辑表 `users` 的 `INSERT` SQL 语句。
    - **ShardingSphere-JDBC** 拦截此 SQL 命令。根据其为 `user_id` 键配置的分片算法，它确定目标物理数据库（例如 `user_db_0`）和物理表（例如 `users_1`）。
    - 用户的数据（带有加密后的密码）被写入 **MySQL** 中正确的物理表。此数据库操作被注册为 Seata 事务的第一个分支。
5. **为角色绑定进行 RPC 调用 (**`user-service`** -> **`permission-service`**)**:
    - `user-service` 调用其 `PermissionFeignClient`（一个声明式的 **OpenFeign** 接口）来调用 `bindDefaultRole` 方法。
    - **Nacos** 提供服务发现，将逻辑服务名 `permission-service` 解析为具体的 IP 和端口，从而实现 RPC 调用。
    - 请求被发送到 `permission-service` 的 `/permission/internal/roles/bind-default` 端点，并携带新的 `userId`。
6. **角色持久化 (**`permission-service`**)**:
    - `permission-service` 接收到内部请求。
    - 它在其专用的 **MySQL** 数据库 (`permission_db`) 中的 `user_roles` 表里执行一次 `INSERT` 操作，将 `userId` 与默认的“普通用户(user)”的 `role_id` 关联起来。
    - 此操作被注册为 Seata 事务的第二个分支。
7. **事务提交**: 两个数据库操作都成功了。`permission-service` 向 `user-service` 返回一个成功信号。`user-service` 的方法执行完成，**Seata** 的事务协调器 (TC) 提交全局事务。
8. **异步日志记录 (**`user-service`**)**:
    - 成功提交后，`user-service` 构建一个日志事件对象 (例如 `OperationLogEvent`)。
    - 它将此对象作为消息发送到一个 **RocketMQ** 主题。消息包含 `userId`、`action: "REGISTER"` 和用户 IP 地址等详细信息。
9. **API 响应**: `user-service` 向客户端返回一个 `200 OK` 响应，其中包含新用户的 ID 和用户名，例如 `{ "code": 200, "message": "注册成功", "data": { "userId": 12345, "username": "newUser" } }`。

##### **异常流程**
+ **用户名重复**:
    1. 在步骤 4，向 MySQL `users` 表的 `INSERT` 操作因 `uk_username` 唯一约束而失败。
    2. 数据库抛出异常，被 `user-service` 捕获。
    3. **Seata** 被通知失败，并立即回滚全局事务（尽管此时还没有其他分支）。
    4. `user-service` 向客户端返回 `409 Conflict` 错误，并且不会向 RocketMQ 发送消息。
+ `permission-service`** 服务宕机**:
    1. 在步骤 5，OpenFeign 调用失败，因为 Nacos 找不到 `permission-service` 的健康实例。
    2. `user-service` 捕获该异常。
    3. **Seata** 启动全局回滚。它向第一个分支所涉及的资源发送一个补偿命令。
    4. `user-service` 中的 Seata 资源管理器 (RM) 执行一条 `DELETE FROM users WHERE user_id = ?` 语句，以移除新创建的用户，确保数据原子性。
    5. `user-service` 返回 `503 Service Unavailable` 错误，并且不会向 RocketMQ 发送消息。

---

#### **2. 用例: 用户登录**
+ **Actor(s)**: 未认证的用户 (公开)
+ **目标**: 进行身份验证并接收一个用于访问受保护资源的 JWT 令牌。
+ **前置条件**: 用户必须有一个已注册的账户。

##### **基本流程 (Happy Path)**
1. **API 请求**: 客户端发送一个 `POST` 请求到 `/user/login`，携带 `{ "username": "string", "password": "string" }`。
2. **用户检索 (**`user-service`**)**:
    - 服务接收到请求。
    - 它使用 **ShardingSphere-JDBC** 按 `username` 查询逻辑表 `users`。由于 `username` 不是分片键，ShardingSphere 将把此查询广播到所有物理的 `users` 表（`user_db_0` 和 `user_db_1` 中的 `users_0` 和 `users_1`）并合并结果。
    - 用户的记录，包括哈希过的密码，从 **MySQL** 中被检索出来。
3. **身份验证 (**`user-service`**)**: 服务将提供的密码与存储的哈希值进行比较。
4. **令牌生成 (**`user-service`**)**: 验证成功后，服务使用一个库来创建一个 **JSON Web Token (JWT)**。JWT 的 payload 包含像 `userId` 和过期时间之类的声明 (claims)。
5. **异步日志记录 (**`user-service`**)**: 服务向 **RocketMQ** 发送一条 "LOGIN" 事件消息。
6. **API 响应**: `user-service` 返回一个 `200 OK` 响应，其中包含 JWT 及其有效期，例如 `{ "code": 200, "message": "登录成功", "data": { "token": "ey...", "expiresIn": 7200 } }`。

##### **异常流程**
+ **凭证无效**:
    1. 在步骤 3，密码比较失败，或者在步骤 2，没有找到用户。
    2. 服务返回 `401 Unauthorized` 错误。不会生成 JWT，也不会发送日志消息。
+ **数据库不可用**:
    1. 在步骤 2，ShardingSphere-JDBC 无法连接到 MySQL 数据库。
    2. 抛出异常。服务返回 `503 Service Unavailable` 错误。

---

#### **3. 用例: 用户登出**
+ **Actor(s)**: 已登录的用户
+ **目标**: 记录用户的登出行为。
+ **前置条件**: 用户已登录并提供一个有效的 JWT。

##### **基本流程 (Happy Path)**
1. **API 请求**: 客户端发送一个 `POST` 请求到 `/user/logout`，并携带一个有效的 `Authorization: Bearer <jwt_token>` 请求头。
2. **令牌验证 (**`user-service`**)**: 一个拦截器或安全过滤器验证 **JWT**。如果有效，它会提取出 `userId`。
3. **异步日志记录 (**`user-service`**)**: 服务向 **RocketMQ** 发送一条 "LOGOUT" 事件消息。设计文档指出，要真正使 JWT 失效，需要使用像 Redis 这样的缓存实现黑名单方法，但对于本系统，简化为仅记录操作。
4. **API 响应**: 服务返回一个 `200 OK` 响应：`{ "code": 200, "message": "登出成功", "data": null }`。

##### **异常流程**
+ **令牌无效/过期**:
    1. 在步骤 2，JWT 验证失败。
    2. 安全过滤器拒绝该请求，返回 `401 Unauthorized` 错误。

---

#### **4. 用例: 获取当前登录用户信息**
+ **Actor(s)**: 已登录的用户
+ **目标**: 检索用户自己的个人资料信息。
+ **前置条件**: 用户已登录并提供一个有效的 JWT。

##### **基本流程 (Happy Path)**
1. **API 请求**: 客户端发送一个 `GET` 请求到 `/user/me`，并在请求头中携带一个有效的 JWT。
2. **令牌验证 (**`user-service`**)**: 一个安全过滤器验证 **JWT** 并从其 payload 中提取出 `userId`。
3. **数据检索 (**`user-service`**)**:
    - 服务使用提取出的 `userId` 来查询逻辑表 `users`。
    - **ShardingSphere-JDBC** 使用 `userId` (分片键) 将 `SELECT` 查询直接路由到正确的单一物理表和数据库，这非常高效。
4. **API 响应**: 服务返回一个 `200 OK`，其中包含用户的数据（密码除外）。

##### **异常流程**
+ **用户未找到**:
    1. 在步骤 3，没有找到令牌中 `userId` 对应的用户（一个不太可能的边缘情况，例如用户在令牌签发后被删除）。
    2. 服务返回 `404 Not Found` 错误。

---

#### **5. 用例: 分页查询用户列表**
+ **Actor(s)**: 管理员, 超级管理员
+ **目标**: 获取一个可分页、可排序、可筛选的用户列表。
+ **前置条件**: Actor 以“管理员”或“超级管理员”角色登录。

##### **基本流程 (Happy Path)**
1. **API 请求**: 一个管理员客户端发送一个 `GET` 请求到 `/user/users`，带有查询参数如 `?page=1&size=10&sort=gmt_create,desc&username=test` 和一个有效的 JWT。
2. **认证和授权 (**`user-service`**)**:
    - 安全过滤器验证 **JWT** 并提取操作者的 `userId`。
    - 为了检查权限，`user-service` 通过 **OpenFeign** 向 `permission-service` 的 `/internal/user/{userId}/role` 端点发起 RPC 调用，该端点通过 **Nacos** 进行服务发现。
    - `permission-service` 查询其 **MySQL** 数据库并返回操作者的角色代码 (例如 "admin" 或 "super_admin")。
    - `user-service` 验证该角色拥有足够的权限。
3. **数据检索 (**`user-service`**)**:
    - 服务对逻辑表 `users` 执行一个分页查询。
    - **ShardingSphere-JDBC** 处理跨数据库、跨表的复杂分页和排序任务，在将结果返回给服务前进行合并。
4. **API 响应**: 服务返回一个 `200 OK`，其中包含分页的用户数据。

##### **异常流程**
+ **权限被拒绝**:
    1. 在步骤 2，从 `permission-service` 返回的角色是 'user'。
    2. `user-service` 拒绝该请求并返回 `403 Forbidden` 错误。

---

#### **6. & 7. 用例: 查询/修改指定用户信息**
+ **Actor(s)**: 用户本人, 管理员, 超级管理员
+ **目标**: 查看或更新特定用户的个人资料。
+ **前置条件**: Actor 已登录并拥有相应权限。

##### **基本流程 (Happy Path)**
1. **API 请求**: 客户端发送一个 `GET` (用于查询) 或 `PUT` (用于修改) 请求到 `/user/{userId}`。`PUT` 请求包含一个带有待更新字段的请求体。需要一个有效的 JWT。
2. **认证和授权 (**`user-service`**)**:
    - 服务验证 **JWT** 并获取操作者的 `userId`。
    - 它检查操作者的 `userId` 是否与 URL 路径中的 `{userId}` 匹配。如果匹配，则授予权限 ("本人")。
    - 如果不匹配，它通过 **OpenFeign** 向 `permission-service` 发起 RPC 调用以获取操作者的角色。
    - 然后它检查角色是否为 'admin' 或 'super_admin'，并相应地授予权限。
3. **数据库操作 (**`user-service`**)**:
    - `GET`: 它使用 `{userId}` 作为分片键执行一个 `SELECT` 查询。**ShardingSphere-JDBC** 将其高效地路由到 **MySQL** 中正确的物理表。
    - `PUT`: 它执行一个 `UPDATE` 语句，同样由 ShardingSphere-JDBC 高效路由。
4. **异步日志记录 (对于 **`PUT`**)**: 如果操作是 `PUT`，服务向 **RocketMQ** 发送一条 "UPDATE_USER_INFO" 消息，消息详情中可能包含变更的数据。
5. **API 响应**: 返回 `200 OK`，其中包含所请求的/更新后的用户对象。

##### **异常流程**
+ **权限被拒绝**:
    1. 在步骤 2，一个 'user' 尝试访问另一个用户的数据，或者一个 'admin' 尝试访问一个 'super_admin'。
    2. 服务返回 `403 Forbidden` 错误。
+ **用户未找到**:
    1. 在步骤 3，`{userId}` 不存在。
    2. 服务返回 `404 Not Found` 错误。

---

#### **8. & 9. 用例: 修改/重置密码**
+ **Actor(s)**: 用户本人 (修改), 管理员/超级管理员 (重置)
+ **目标**: 更新用户的密码。
+ **前置条件**: Actor 已登录并拥有相应权限。

##### **基本流程 (Happy Path)**
1. **API 请求**:
    - **修改**: `PUT` 到 `/user/password`，请求体为 `{ "oldPassword": "...", "newPassword": "..." }`。
    - **重置**: `POST` 到 `/user/user/{userId}/reset-password`。
2. **认证和授权 (**`user-service`**)**:
    - **修改**: 服务从 JWT 获取 `userId`。它通过 **ShardingSphere-JDBC** 从 **MySQL** 查询用户并验证 `oldPassword`。
    - **重置**: 服务执行与用例 7 中相同的权限检查，以确保操作者是 admin/super_admin。
3. **数据库操作 (**`user-service`**)**: 服务更新目标 `userId` 的 `users` 表中的密码字段。新密码会先被加密。**ShardingSphere-JDBC** 路由 `UPDATE` 语句。
4. **异步日志记录 (**`user-service`**)**: 一条适当的日志消息 ("CHANGE_PASSWORD" 或 "RESET_PASSWORD") 被发送到 **RocketMQ**。
5. **API 响应**: 返回 `200 OK`。重置密码的响应可能包含新的临时密码。

##### **异常流程**
+ **旧密码不正确**:
    1. 对于“修改”流程，`oldPassword` 不匹配。
    2. 服务返回 `400 Bad Request` 错误。
+ **权限被拒绝**:
    1. 对于“重置”流程，一个用户试图在没有管理员权限的情况下重置另一个用户的密码。
    2. 服务返回 `403 Forbidden` 错误。

### **第二部分: 权限服务用例**
`permission-service` 是一个面向内部的服务，用于管理角色及其与用户的分配关系。

---

#### **1. 用例: 角色数据初始化**
+ **Actor(s)**: 系统 (启动时)
+ **目标**: 确保服务启动时，基本角色存在于数据库中。
+ **前置条件**: `permission-service` 正在启动。

##### **基本流程 (Happy Path)**
1. **启动触发 (**`permission-service`**)**: **Spring Boot** 应用启动。一个被 `@PostConstruct` 注解或实现了 `CommandLineRunner` 接口的组件被触发。
2. **数据库检查 (**`permission-service`**)**: 该组件查询其 **MySQL** 数据库 (`permission_db`) 中的 `roles` 表，以查看像 'super_admin', 'admin', 'user' 这样的角色是否存在。
3. **数据填充 (**`permission-service`**)**: 如果角色缺失，该组件执行 `INSERT` 语句来创建它们。它还可以初始化一个默认的超级管理员用户（例如，将 `userId` 1 绑定到 `super_admin` 角色）。
4. **完成**: 服务继续其启动过程。

##### **异常流程**
+ **数据库不可用**:
    1. 在步骤 2，服务无法连接到 `permission_db`。
    2. 启动过程将失败，Spring Boot 应用将关闭，从而防止服务在不一致的状态下运行。

---

#### **2. & 3. 用例: 绑定默认角色 / 查询用户角色**
+ **Actor(s)**: `user-service` (系统内部)
+ **目标**: 在注册期间分配默认角色，或检索用户的角色以进行权限检查。
+ **前置条件**: `user-service` 发起一个 RPC 调用。

##### **基本流程 (Happy Path)**
1. **API 请求 (**`permission-service`**)**: 服务通过 **OpenFeign** 从 `user-service` 接收一个内部请求。
    - **绑定**: `POST`到 `/permission/internal/roles/bind-default`，携带一个 `userId`。
    - **查询**: `GET`到 `/permission/internal/user/{userId}/role`。
2. **数据库操作 (**`permission-service`**)**:
    - **绑定**: 它对 `user_roles` 表执行一个 `INSERT`。如果在用户注册过程中调用，此操作是 **Seata** 分布式事务中的一个分支。
    - **查询**: 它执行一个 `SELECT` 语句，连接 `user_roles` 和 `roles` 表，以查找给定 `userId` 的 `role_code`。
3. **API 响应**:
    - **绑定**: 向调用方 `user-service` 返回 `200 OK` 或 `204 No Content`。
    - **查询**: 返回一个 `200 OK`，其中包含角色数据，例如 `{ "code": 200, "message": "Success", "data": { "roleCode": "admin" } }`。

##### **异常流程**
+ **Seata 回滚 (绑定)**:
    1. `INSERT` 操作失败（例如，`uk_user_id` 索引中的 `user_id` 重复），或者全局事务被 `user-service` 回滚。
    2. **Seata** 确保在 `user_roles` 上的 `INSERT` 操作被撤销。
+ **用户没有角色 (查询)**:
    1. `SELECT` 查询没有返回结果。
    2. 服务应返回一个合理的默认值或一个错误，调用方 `user-service` 必须优雅地处理此情况（例如，通过拒绝访问）。

---

#### **4. & 5. 用例: 升级/降级用户角色**
+ **Actor(s)**: 超级管理员
+ **目标**: 在 'user' 和 'admin' 之间更改用户的角色。
+ **前置条件**: Actor 以 'super_admin' 角色登录。

##### **基本流程 (Happy Path)**
1. **API 请求 (**`permission-service`**)**: 一个超级管理员通过前端，发送一个请求到 `permission-service`。
    - **升级**: `PUT` 到 `/permission/user/{userId}/upgrade-to-admin`。
    - **降级**: `PUT` 到 `/permission/user/{userId}/downgrade-to-user`。
2. **认证**: 请求必须通过一个安全过滤器，该过滤器验证 JWT 并确认操作者拥有 'super_admin' 角色。（这意味着 `permission-service` 也有一个检查角色的机制）。
3. **数据库操作 (**`permission-service`**)**: 服务对 `user_roles` 表执行一个 `UPDATE`，更改指定 `userId` 的 `role_id`。
4. **异步日志记录 (**`permission-service`**)**: 服务可以有选择地向 **RocketMQ** 发送自己的日志消息 ("UPGRADE_ROLE", "DOWNGRADE_ROLE")，以记录这些关键的安全事件。
5. **API 响应**: 返回一个 `200 OK` 确认变更。

##### **异常流程**
+ **权限被拒绝**:
    1. 在步骤 2，操作者不是 'super_admin'。
    2. 服务返回 `403 Forbidden` 错误。
+ **用户未找到**:
    1. 在步骤 3，`user_roles` 中不存在给定 `userId` 的条目。
    2. 服务返回 `404 Not Found` 错误。

### **第三部分: 日志服务用例**
`logging-service` 是一个没有直接 API 暴露的后台处理器。

---

#### **1. 用例: 异步记录操作日志**
+ **Actor(s)**: 系统 (`user-service`, `permission-service`)
+ **目标**: 从消息队列中消费日志消息并将其持久化到数据库。
+ **前置条件**: 相关 RocketMQ 主题中存在一条消息。

##### **基本流程 (Happy Path)**
1. **消息消费 (**`logging-service`**)**:
    - `logging-service` 的 **Spring Boot** 应用包含一个监听器组件。
    - 该监听器被 `@RocketMQMessageListener` 注解，使其订阅 **RocketMQ** 中的日志主题。
    - RocketMQ 将消息推送给该监听器。
2. **消息处理 (**`logging-service`**)**:
    - 监听器接收到消息的 payload (即 `OperationLogEvent` 对象)。
    - 它反序列化 payload 并将其字段 (例如 `userId`, `action`, `detail`) 映射到一个 `OperationLog` 数据库实体。
3. **数据持久化 (**`logging-service`**)**: 服务使用其仓库对 `OperationLog` 实体执行一次 `INSERT` 操作，将其写入 `logging_db` **MySQL** 数据库的 `operation_logs` 表中。
4. **确认**: 成功插入后，RocketMQ 监听器确认该消息，将其从队列中移除。

##### **异常流程**
+ **数据库不可用**:
    1. 在步骤 3，`logging-service` 无法连接到 `logging_db`。
    2. `INSERT` 失败，并抛出异常。
    3. RocketMQ 监听器不确认该消息。RocketMQ 将在配置的延迟后尝试重新投递消息，提供了一个重试机制。如果重试持续失败，消息最终将被发送到“死信队列”以供人工检查。
+ **无效的消息格式**:
    1. 在步骤 2，消息 payload 无法被反序列化为 `OperationLogEvent`。
    2. 这是一条毒丸消息。监听器应捕获反序列化异常，记录有问题的消息内容以供调试，并确认该消息以防止其阻塞队列。

